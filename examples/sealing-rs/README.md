# Enclave-Native Reproducible Key

This project demonstrates a cryptographic pattern for creating a secure, reproducible secret key within a hardware-based secure enclave. It acts as a foundational building block for more complex decentralized and trustless applications.

The server deterministically generates a key pair (`secp256k1::SecretKey`, `secp256k1::PublicKey`) from an AWS KMS key and exposes the public key, while guaranteeing that the **private key never leaves the enclave**.

## Core Concept

The goal is to generate a private key inside an enclave in a way that is both **secure** and **reproducible**. Any party can run this same enclave, provide the same KMS key, and derive the exact same internal secret, without that secret ever being known to the party or any other observer.

This allows the enclave to perform deterministic cryptographic operations, such as signing messages, where the resulting signature can be trusted because it was created by specific, audited code running in a verified environment.

## How It Works

The process consists of two main stages:

1.  **Startup: NUMS Key Generation**
    *   On initialization, the server generates a "Nothing-Up-My-Sleeve" (NUMS) public key.
    *   This key is generated by hashing a public seed string (`"This is a secp256k1 NUMS key"`) and incrementing a counter until a valid point on the `secp256k1` curve is found.
    *   This process proves that the corresponding private key for the NUMS key is unknown to anyone.

2.  **Runtime: API Endpoints**
    *   `POST /generate-secret`: A user provides the ARN of an AWS KMS key. The enclave uses its NUMS key and the provided KMS key to call `kms:DeriveSharedSecret`. The result is a 32-byte shared secret. This secret is then deterministically converted into a valid `secp256k1::SecretKey` and stored immutably in memory. This endpoint can only be successfully called **once**.
    *   `GET /retrieve-public-key`: This endpoint returns the `PublicKey` corresponding to the securely stored `SecretKey`. The public key is cached for instant, lock-free reads.

## Security & Trust Model

*   **Confidentiality**: The final `SecretKey` is born inside the enclave and never leaves it. All operations on the key happen within the secure boundary.
*   **Reproducibility**: The key generation is entirely deterministic. The same enclave code + the same KMS key ARN will *always* result in the same secret key pair.
*   **Trustlessness via Attestation**: The true power of this model is realized when the AWS KMS key policy is configured to grant `DeriveSharedSecret` permissions **only** to an enclave with a specific cryptographic measurement (the `PCR0` hash), from the moment the key is created. This ensures that no other machine in the world can derive the secret, under the trust assumptions of AWS Nitro and AWS KMS.

## A Foundation for Larger Projects

This server is designed as a minimal, secure core. It provides a deterministic, confidential key, and larger projects can build on this foundation to perform powerful computations, such as:

*   **Deterministic Signing**: Create a trustless oracle or notary that signs data.
*   **Threshold Signature Schemes**: Act as a participant in a multi-party computation (MPC) network.
*   **Private Data Computation**: Use the key to decrypt and perform computations on confidential encrypted data, with publicly attested results.

## Usage

1.  **Build** the EIF file with Nix using `nix build .x86_64-eif` or `nix build .aarch64-eif`.
2.  **Deploy** the EIF to a Nitro-enabled EC2 instance and run it using `enclaver`.
3.  **Configure** an AWS KMS key with a policy that allows your enclave's `PCR0` hash to call `kms:DeriveSharedSecret`.
4.  **Generate the Secret**:
    ```bash
    curl -X POST http://localhost:8000/generate-secret \
      -H "Content-Type: application/json" \
      -d '{
        "key_id": "arn:aws:kms:us-east-1:123456789012:key/your-kms-key-id"
      }'
    ```
5.  **Retrieve the Public Key**:
    ```bash
    curl http://localhost:8000/retrieve-public-key
    ```

## Running Locally

To run this project locally, first enter the Nix development shell:

```
nix develop
```

Then build the application and run it:
```
cargo build
cargo run
```

To interact with AWS KMS locally, set the following environment variables before running the application:
```
export AWS_ACCESS_KEY_ID=$(aws configure get aws_access_key_id)
export AWS_SECRET_ACCESS_KEY=$(aws configure get aws_secret_access_key)
export AWS_SESSION_TOKEN=$(aws configure get aws_session_token)
export AWS_DEFAULT_REGION=<your region>
```